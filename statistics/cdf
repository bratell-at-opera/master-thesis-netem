#!/usr/bin/env python3

import statistics
import sys
import os
import json
from scenarios import scenarios, \
                      bandwidth_scenarios, \
                      latency_scenarios, \
                      loss_scenarios, \
                      baseline_scenarios
import subprocess
from matplotlib import pyplot,rcParams


this_folder = os.path.dirname(os.path.realpath(__file__))
fig_nr = 1
axis_label_offset = -2.5
axis_unit_offset = 0.0
legend_size = 10
rcParams.update({'font.size': 14})

compare_keys = {
    "Time (ms)": "time",
    "Bytes fetched (kB)": "total_bytes_fetched"
}

scenarios_to_check = scenarios
compare_key = "Time (ms)"
if len(sys.argv) > 1:
    if sys.argv[1] == "--res-count":
        compare_key = "resource_count"
    elif sys.argv[1] == "--bytes":
        compare_key = "Bytes fetched (kB)"
if len(sys.argv) == 3:
    if sys.argv[2] == "--bandwidth":
        scenarios_to_check = bandwidth_scenarios
    if sys.argv[2] == "--loss":
        scenarios_to_check = loss_scenarios
    if sys.argv[2] == "--latency":
        scenarios_to_check = latency_scenarios
    if sys.argv[2] == "--baseline":
        scenarios_to_check = baseline_scenarios

for scen in scenarios_to_check:
    # Open connections
    process = subprocess.Popen(
        [this_folder + os.path.sep + "generate-stats"] +
        scen[1] +
        ["--open-connection", "-h1"],
        stdout=subprocess.PIPE
        )
    http1_out, http1_err = process.communicate()
    process = subprocess.Popen(
        [this_folder + os.path.sep + "generate-stats"] +
        scen[1] +
        ["--open-connection", "-h2"],
        stdout=subprocess.PIPE
        )
    http2_out, http2_err = process.communicate()
    process = subprocess.Popen(
        [this_folder + os.path.sep + "generate-stats"] +
        scen[1] +
        ["--open-connection", "-q", "-pq"],
        stdout=subprocess.PIPE
        )
    quic_out, quic_err = process.communicate()

    outs = []
    outs.append(json.loads(http1_out.decode('utf-8')))
    outs.append(json.loads(http2_out.decode('utf-8')))
    outs.append(json.loads(quic_out.decode('utf-8')))

    # Create plot
    fig, ax = pyplot.subplots()

    for data in outs:
        nr_urls = 0
        urls = []
        url_means = []
        values = list()

        for url, stats_list in data["webpages"].items():
            new_values = []
            for stat in stats_list:
                if stat["status"] is True:
                    new_values.append(stat[compare_keys[compare_key]])
            if len(new_values) != 0:
                url_means.append(
                    statistics.mean(new_values)
                    )
                urls.append(url)
                nr_urls = nr_urls + 1
            values += new_values

        url_means.sort()
        values.sort()
        cdf_scaler = []
        y_value = 0
        for i in range(0, len(values)):
            cdf_scaler.append(y_value)
            y_value += 1/float(len(values))

        ax.errorbar(
            values,
            cdf_scaler,
            label=data["identifiers"]["web_protocol"]
            )
        #pyplot.plot(url_means, cdf_scaler)
    pyplot.xlabel(compare_key, labelpad=axis_label_offset)
    pyplot.ylabel('Probability less than X', labelpad=axis_label_offset)
    pyplot.title('CDF Open connection ' + scen[0])
    pyplot.legend(
        bbox_to_anchor=(0.98, 0.285),
        loc=1,
        borderaxespad=axis_unit_offset,
        prop={"size": legend_size}
        )
    pyplot.grid(True)


for scen in scenarios_to_check:
    # Closed connections
    process = subprocess.Popen(
        [this_folder + os.path.sep + "generate-stats"] +
        scen[1] +
        ["-h1"],
        stdout=subprocess.PIPE
        )
    http1_out, http1_err = process.communicate()
    process = subprocess.Popen(
        [this_folder + os.path.sep + "generate-stats"] +
        scen[1] +
        ["-h2"],
        stdout=subprocess.PIPE
        )
    http2_out, http2_err = process.communicate()
    process = subprocess.Popen(
        [this_folder + os.path.sep + "generate-stats"] +
        scen[1] +
        ["-q", "-pq"],
        stdout=subprocess.PIPE
        )
    quic_out, quic_err = process.communicate()

    outs = []
    outs.append(json.loads(http1_out.decode('utf-8')))
    outs.append(json.loads(http2_out.decode('utf-8')))
    outs.append(json.loads(quic_out.decode('utf-8')))

    # Create plot
    fig, ax = pyplot.subplots()

    for data in outs:
        nr_urls = 0
        urls = []
        url_means = []
        values = list()

        for url, stats_list in data["webpages"].items():
            new_values = []
            for stat in stats_list:
                if stat["status"] is True:
                    if compare_keys[compare_key] == "total_bytes_fetched":
                        new_values.append(stat[compare_keys[compare_key]] / 1000.0)
                    else:
                        new_values.append(stat[compare_keys[compare_key]])
            if len(new_values) != 0:
                url_means.append(
                    statistics.mean(new_values)
                    )
                urls.append(url)
                nr_urls = nr_urls + 1
            values += new_values

        url_means.sort()
        values.sort()
        cdf_scaler = []
        y_value = 0
        for i in range(0, len(values)):
            cdf_scaler.append(y_value)
            y_value += 1/float(len(values))

        ax.errorbar(
            values,
            cdf_scaler,
            label=data["identifiers"]["web_protocol"]
            )
        #pyplot.plot(url_means, cdf_scaler)
    pyplot.xlabel(compare_key, labelpad=axis_label_offset)
    pyplot.ylabel('Probability less than X', labelpad=axis_label_offset)
    pyplot.title('CDF Closed connection ' + scen[0])
    pyplot.legend(
        bbox_to_anchor=(0.98, 0.285),
        loc=1,
        borderaxespad=axis_unit_offset,
        prop={'size':legend_size}
        )
    pyplot.grid(True)


pyplot.show()
